# 动态规划

以[爬楼梯](https://leetcode.cn/problems/climbing-stairs/)为例，动态规划比暴力快的原因是：动态规划不用重复计算子状态（从第i阶楼梯到楼顶的爬法）

记忆化搜索与动态规划的区别在于  
1. 函数入参即是子状态（没有dp数组）
2. 函数的调用蕴含这子状态直接的关系
3. 记忆化搜索在空间复杂度上多了函数调用的栈开销

*注：为了编码方便以及便以理解，下面的动态规划相关题目都使用记忆化搜索实现*

## [最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)
给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。
 
**示例 1：**  
    输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]  
    输出：3  
    解释：长度最长的公共子数组是 [3,2,1] 。

**示例 2：**  
    输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]  
    输出：5
 
>提示：  
>1 <= nums1.length, nums2.length <= 1000  
>0 <= nums1[i], nums2[i] <= 100

??? tip "思路"

    TODO    

??? example "示例代码"

    ```python
    class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        dp=[[0 for _ in nums2] for _ in nums1]
        res=0
        for i in range(len(nums2)):
            if nums1[0]==nums2[i]:
                dp[0][i]=1
                res=max(res,dp[0][i])
        for i in range(len(nums1)):
            if nums1[i]==nums2[0]:
                dp[i][0]=1
                res=max(res,dp[i][0])
        
        for i in range(1,len(nums1)):
            for j in range(1,len(nums2)):
                if nums1[i]==nums2[j]:
                    dp[i][j]=dp[i-1][j-1]+1
                    res=max(res,dp[i][j])
                    
        return res
    ```


## [最短公共超序列](https://leetcode.cn/problems/shortest-common-supersequence/)
---
√

给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。

（如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 任意位置），可以得到字符串 S，那么 S 就是 T 的子序列）

 

**示例：**

    输入：str1 = "abac", str2 = "cab"
    输出："cabac"
    解释：
    str1 = "abac" 是 "cabac" 的一个子串，因为我们可以删去 "cabac" 的第一个 "c"得到 "abac"。 
    str2 = "cab" 是 "cabac" 的一个子串，因为我们可以删去 "cabac" 末尾的 "ac" 得到 "cab"。
    最终我们给出的答案是满足上述属性的最短字符串。
     

>提示：  
>1 <= str1.length, str2.length <= 1000  
>str1 和 str2 都由小写英文字母组成。


??? tip "思路"

    求最短公共子序列    


??? example "示例代码"

    ```python
    class Solution:
        def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
            @lru_cache(None)
            def getSCS(i,j):
                if i==len(str1) or j==len(str2):
                    return ""
                res=""
                if str1[i]==str2[j]:
                    res=str1[i]+getSCS(i+1,j+1)
                t1,t2=getSCS(i,j+1),getSCS(i+1,j)
                if len(res)<len(t1):
                    res=t1
                if len(res)<len(t2):
                    res=t2
                return res
            SCS=getSCS(0,0)
            i,j,x=0,0,0
            res=""
            while i<len(str1) or j<len(str2):
                if x==len(SCS):
                    res+=str1[i:]+str2[j:]
                    break
                else:
                    ii,jj=i,j
                    while SCS[x]!=str1[ii]:
                        ii+=1
                    while SCS[x]!=str2[jj]:
                        jj+=1
                    res+=str1[i:ii]+str2[j:jj]+SCS[x]
                    i=ii+1
                    j=jj+1
                    x+=1
            return res
    ```